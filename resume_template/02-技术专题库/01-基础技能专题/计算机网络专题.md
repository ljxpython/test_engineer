# 计算机网络专题

## 📝 专题概述
本专题涵盖高级测试开发工程师计算机网络相关的面试题目，包括网络协议、HTTP/HTTPS、TCP/UDP、网络调试工具、性能优化等核心知识点。

## 🎯 知识要点
- OSI七层模型和TCP/IP协议栈
- HTTP/HTTPS协议原理和应用
- TCP/UDP协议特性和区别
- 网络调试和抓包工具使用
- 网络性能优化和故障排查
- 在测试中的网络应用场景

---

## 🏗️ 网络基础类

### ⭐ OSI七层模型，HTTP协议在哪一层，TCP协议在哪一层？
**难度**：⭐
**频率**：🔥🔥🔥

**标准答案**：
OSI（Open System Interconnection）七层模型是网络通信的理论基础：

**OSI七层模型**：
```bash
7. 应用层 (Application Layer)    - HTTP、HTTPS、FTP、SMTP、DNS
6. 表示层 (Presentation Layer)  - 数据加密、压缩、格式转换
5. 会话层 (Session Layer)       - 会话管理、连接建立和维护
4. 传输层 (Transport Layer)     - TCP、UDP、端口管理
3. 网络层 (Network Layer)       - IP、ICMP、路由
2. 数据链路层 (Data Link Layer) - 以太网、WiFi、MAC地址
1. 物理层 (Physical Layer)      - 电缆、光纤、无线信号
```

**协议层级定位**：
- **HTTP协议**：位于**第7层（应用层）**
  - 基于TCP协议的应用层协议
  - 用于Web浏览器和服务器之间的通信
  - 定义了请求/响应的消息格式

- **TCP协议**：位于**第4层（传输层）**
  - 提供可靠的、面向连接的数据传输
  - 负责数据分段、重传、流量控制
  - 为应用层提供端到端的通信服务

**实际协议栈示例**：
```bash
# 访问 https://api.example.com/users 的协议栈
应用层:   HTTP请求 "GET /users HTTP/1.1"
表示层:   TLS/SSL 加密
会话层:   TCP会话管理
传输层:   TCP (源端口:随机, 目标端口:443)
网络层:   IP (源IP:本机, 目标IP:服务器IP)
数据链路层: 以太网帧 (MAC地址)
物理层:   网线/WiFi信号传输
```

**TCP/IP四层模型对比**：
在实际应用中，更常用TCP/IP四层模型：
```bash
4. 应用层   - HTTP、HTTPS、DNS、SMTP (对应OSI 5-7层)
3. 传输层   - TCP、UDP (对应OSI第4层)
2. 网络层   - IP、ICMP (对应OSI第3层)
1. 链路层   - 以太网、WiFi (对应OSI 1-2层)
```

**在测试中的应用**：
理解协议分层有助于：
- **接口测试**：理解HTTP请求的完整过程
- **性能测试**：分析网络延迟的来源
- **问题定位**：区分应用层和传输层问题
- **安全测试**：理解不同层的安全威胁

**实际案例**：
```bash
# 测试中的分层思考
问题: API响应慢
分析思路:
- 应用层: HTTP响应码、响应时间
- 传输层: TCP连接时间、数据传输时间  
- 网络层: 路由延迟、丢包率
- 物理层: 带宽限制、网络拥塞
```

### ⭐⭐ TCP的三次握手和四次挥手过程
**难度**：⭐⭐
**频率**：🔥🔥🔥

**标准答案**：
TCP三次握手和四次挥手是TCP协议建立和关闭连接的标准过程：

**三次握手（建立连接）**：
```bash
客户端                    服务器
  |                        |
  |------- SYN=1 -------->|  第1次握手：客户端发送SYN
  |     seq=x              |
  |                        |
  |<-- SYN=1,ACK=1 -------|  第2次握手：服务器发送SYN+ACK
  |   seq=y,ack=x+1        |
  |                        |
  |------- ACK=1 -------->|  第3次握手：客户端发送ACK
  |     ack=y+1            |
  |                        |
  连接建立成功
```

**详细过程说明**：
1. **第一次握手**：
   - 客户端发送SYN=1，seq=x（随机序列号）
   - 客户端进入SYN_SENT状态

2. **第二次握手**：
   - 服务器收到SYN，发送SYN=1，ACK=1，seq=y，ack=x+1
   - 服务器进入SYN_RCVD状态

3. **第三次握手**：
   - 客户端发送ACK=1，ack=y+1
   - 双方进入ESTABLISHED状态，连接建立

**四次挥手（关闭连接）**：
```bash
客户端                    服务器
  |                        |
  |------- FIN=1 -------->|  第1次挥手：客户端请求关闭
  |     seq=u              |
  |                        |
  |<------ ACK=1 ---------|  第2次挥手：服务器确认
  |     ack=u+1            |
  |                        |
  |<------ FIN=1 ---------|  第3次挥手：服务器请求关闭
  |     seq=v              |
  |                        |
  |------- ACK=1 -------->|  第4次挥手：客户端确认
  |     ack=v+1            |
  |                        |
  连接完全关闭
```

**详细过程说明**：
1. **第一次挥手**：
   - 客户端发送FIN=1，seq=u
   - 客户端进入FIN_WAIT_1状态

2. **第二次挥手**：
   - 服务器发送ACK=1，ack=u+1
   - 服务器进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态

3. **第三次挥手**：
   - 服务器发送FIN=1，seq=v
   - 服务器进入LAST_ACK状态

4. **第四次挥手**：
   - 客户端发送ACK=1，ack=v+1
   - 客户端进入TIME_WAIT状态，服务器进入CLOSED状态
   - 客户端等待2MSL后进入CLOSED状态

**为什么是三次握手？**
```bash
原因分析:
1. 确认双方收发能力正常
   - 第1次：客户端发送能力 ✓
   - 第2次：服务器收发能力 ✓
   - 第3次：客户端接收能力 ✓

2. 防止历史连接
   - 避免已失效的连接请求突然到达服务器
   - 客户端可以在第3次握手时发现并拒绝历史连接

3. 同步序列号
   - 双方需要确认彼此的初始序列号
   - 为后续数据传输做准备
```

**为什么是四次挥手？**
```bash
原因分析:
1. TCP是全双工通信
   - 需要分别关闭两个方向的连接
   - 客户端→服务器方向 (第1、2次挥手)
   - 服务器→客户端方向 (第3、4次挥手)

2. 服务器可能还有数据要发送
   - 收到FIN后先ACK确认
   - 处理完数据后再发送自己的FIN
```

**在测试中的实际应用**：

**1. 连接测试脚本**：
```python
import socket
import time

def test_tcp_connection(host, port):
    """测试TCP连接建立"""
    start_time = time.time()
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        
        # 建立连接（三次握手）
        result = sock.connect_ex((host, port))
        connect_time = time.time() - start_time
        
        if result == 0:
            print(f"✓ 连接成功 {host}:{port}, 耗时: {connect_time:.3f}s")
            
            # 关闭连接（四次挥手）
            sock.close()
            return True
        else:
            print(f"✗ 连接失败 {host}:{port}")
            return False
            
    except Exception as e:
        print(f"✗ 连接异常 {host}:{port}, 错误: {e}")
        return False
```

**2. 使用tcpdump/wireshark观察握手过程**：
```bash
# 抓包观察三次握手
tcpdump -i eth0 -nn host 192.168.1.100 and port 80

# 输出示例：
# 14:30:01.123 IP 192.168.1.10.56789 > 192.168.1.100.80: Flags [S], seq 1000, win 29200
# 14:30:01.124 IP 192.168.1.100.80 > 192.168.1.10.56789: Flags [S.], seq 2000, ack 1001, win 28960
# 14:30:01.125 IP 192.168.1.10.56789 > 192.168.1.100.80: Flags [.], ack 2001, win 229
```

**3. 连接状态监控**：
```bash
# 查看TCP连接状态
netstat -an | grep -E "(LISTEN|SYN_SENT|SYN_RCVD|ESTABLISHED|FIN_WAIT|CLOSE_WAIT|TIME_WAIT)"

# 统计各状态的连接数
netstat -an | awk '/tcp/ {state[$6]++} END {for(s in state) print s, state[s]}'
```

**常见问题和排查**：
- **TIME_WAIT过多**：服务器主动关闭连接导致，可能影响性能
- **CLOSE_WAIT堆积**：应用程序未正确关闭socket
- **连接超时**：网络延迟、防火墙阻拦或服务器负载过高

### ⭐⭐ TCP和UDP的区别
**难度**：⭐⭐
**频率**：🔥🔥🔥

**标准答案**：
TCP和UDP是传输层的两种主要协议，各有不同的特性和应用场景：

**协议特性对比**：

| 特性 | TCP | UDP |
|------|-----|-----|
| 连接性 | 面向连接 | 无连接 |
| 可靠性 | 可靠传输 | 不可靠传输 |
| 顺序保证 | 保证顺序 | 不保证顺序 |
| 重传机制 | 有重传 | 无重传 |
| 流量控制 | 有 | 无 |
| 拥塞控制 | 有 | 无 |
| 头部大小 | 20-60字节 | 8字节 |
| 传输速度 | 较慢 | 较快 |

**TCP协议特性**：
```bash
优势:
✓ 可靠传输 - 确保数据完整到达
✓ 有序传输 - 数据按发送顺序接收
✓ 流量控制 - 防止接收方缓冲区溢出
✓ 拥塞控制 - 网络拥塞时自动调节发送速度
✓ 错误检测 - 自动重传丢失或错误的数据

缺点:
✗ 开销大 - 需要维护连接状态
✗ 延迟高 - 三次握手建立连接
✗ 资源消耗 - 需要更多内存和CPU
```

**UDP协议特性**：
```bash
优势:
✓ 速度快 - 无需建立连接
✓ 开销小 - 头部只有8字节
✓ 支持广播 - 可以一对多通信
✓ 实时性好 - 无需等待确认

缺点:
✗ 不可靠 - 可能丢包、重复、乱序
✗ 无流量控制 - 可能导致数据丢失
✗ 无拥塞控制 - 网络拥塞时不会调节
```

**应用场景对比**：

**TCP适用场景**：
```bash
✓ HTTP/HTTPS - Web服务
✓ FTP - 文件传输
✓ SMTP/POP3 - 邮件服务
✓ SSH - 远程登录
✓ 数据库连接 - MySQL、PostgreSQL
✓ 接口测试 - RESTful API调用

特点: 需要数据完整性和可靠性的场景
```

**UDP适用场景**：
```bash
✓ DNS查询 - 域名解析
✓ 视频直播 - 实时流媒体
✓ 在线游戏 - 实时对战
✓ DHCP - 动态地址分配
✓ 网络监控 - SNMP协议
✓ 日志收集 - syslog协议

特点: 对实时性要求高，能容忍少量数据丢失
```

**代码示例对比**：

**TCP客户端示例**：
```python
import socket

# TCP客户端
def tcp_client():
    # 创建TCP socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    try:
        # 建立连接（三次握手）
        sock.connect(('localhost', 8080))
        
        # 发送数据
        sock.send(b'Hello TCP')
        
        # 接收响应
        response = sock.recv(1024)
        print(f"TCP响应: {response.decode()}")
        
    finally:
        # 关闭连接（四次挥手）
        sock.close()
```

**UDP客户端示例**：
```python
import socket

# UDP客户端
def udp_client():
    # 创建UDP socket
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
    try:
        # 直接发送数据（无需建立连接）
        sock.sendto(b'Hello UDP', ('localhost', 8080))
        
        # 接收响应
        response, server = sock.recvfrom(1024)
        print(f"UDP响应: {response.decode()} from {server}")
        
    finally:
        sock.close()
```

**性能测试对比**：
```python
import time
import socket

def performance_test():
    messages = 1000
    
    # TCP性能测试
    start_time = time.time()
    for i in range(messages):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect(('localhost', 8080))
        sock.send(f'Message {i}'.encode())
        sock.recv(1024)
        sock.close()
    tcp_time = time.time() - start_time
    
    # UDP性能测试  
    start_time = time.time()
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    for i in range(messages):
        sock.sendto(f'Message {i}'.encode(), ('localhost', 8080))
        sock.recvfrom(1024)
    sock.close()
    udp_time = time.time() - start_time
    
    print(f"TCP耗时: {tcp_time:.2f}s")
    print(f"UDP耗时: {udp_time:.2f}s")
    print(f"UDP比TCP快: {tcp_time/udp_time:.1f}倍")
```

**在测试中的选择原则**：

**1. 接口测试**：
```bash
# HTTP API测试 - 使用TCP
优势: 
- 保证数据完整性
- 支持HTTP协议特性
- 便于调试和分析

curl -X POST https://api.example.com/users \
     -H "Content-Type: application/json" \
     -d '{"name": "test"}'
```

**2. 性能测试**：
```bash
# 高并发场景选择
TCP: 需要保证事务完整性的业务场景
UDP: 实时性要求高，可容忍少量数据丢失的场景

# 示例：游戏服务器测试
# 用户操作 - UDP (实时性优先)
# 交易系统 - TCP (可靠性优先)
```

**3. 监控和日志**：
```bash
# 日志收集
UDP syslog: 高吞吐量，允许少量丢失
TCP logging: 关键日志，确保不丢失

# 监控数据上报
UDP: 实时监控指标
TCP: 重要告警信息
```

**实际测试案例**：
在我负责的项目中，遇到实时推送功能的测试：
- **业务消息推送**：使用TCP确保重要通知不丢失
- **在线状态更新**：使用UDP提高实时性
- **测试策略**：分别针对两种协议设计不同的测试用例，验证可靠性和实时性指标

---

## 🌐 HTTP协议类

### ⭐⭐ HTTP和HTTPS的区别
**难度**：⭐⭐
**频率**：🔥🔥🔥

**标准答案**：
HTTP和HTTPS是Web通信中最重要的两个协议，它们的主要区别在于安全性：

**基本概念**：
- **HTTP**：HyperText Transfer Protocol，超文本传输协议
- **HTTPS**：HTTP Secure，基于TLS/SSL的安全HTTP协议

**主要区别对比**：

| 特性 | HTTP | HTTPS |
|------|------|-------|
| 安全性 | 明文传输 | 加密传输 |
| 端口 | 80 | 443 |
| 协议栈 | HTTP + TCP | HTTP + TLS/SSL + TCP |
| 性能 | 较快 | 较慢（加密开销） |
| 证书 | 不需要 | 需要SSL证书 |
| SEO权重 | 普通 | 更高 |
| 浏览器显示 | 无锁标识 | 锁标识 |

**HTTPS加密过程**：
```bash
1. TCP三次握手建立连接
2. TLS握手过程:
   ├─ Client Hello: 客户端发送支持的加密算法
   ├─ Server Hello: 服务器选择加密算法并发送证书
   ├─ 证书验证: 客户端验证服务器证书
   ├─ 密钥交换: 协商对称加密密钥
   └─ 握手完成: 开始加密通信
3. HTTP数据传输（加密）
```

**安全性对比**：

**HTTP安全风险**：
```bash
✗ 数据泄露 - 传输内容可被窃听
✗ 数据篡改 - 传输过程中可被修改
✗ 身份伪造 - 无法确认服务器身份
✗ 会话劫持 - Session ID可被窃取
✗ 中间人攻击 - 可被代理服务器截获
```

**HTTPS安全保障**：
```bash
✓ 数据加密 - TLS/SSL加密保护隐私
✓ 完整性 - 数字签名防止篡改
✓ 身份认证 - 证书验证服务器身份
✓ 防重放 - 序列号防止重放攻击
✓ 前向安全 - 即使私钥泄露，历史通信仍安全
```

**性能影响对比**：
```python
import time
import requests

def performance_test():
    url_http = "http://example.com/api/test"
    url_https = "https://example.com/api/test"
    
    # HTTP测试
    start_time = time.time()
    for i in range(100):
        response = requests.get(url_http)
    http_time = time.time() - start_time
    
    # HTTPS测试
    start_time = time.time()
    for i in range(100):
        response = requests.get(url_https)
    https_time = time.time() - start_time
    
    print(f"HTTP耗时: {http_time:.2f}s")
    print(f"HTTPS耗时: {https_time:.2f}s")
    print(f"HTTPS比HTTP慢: {(https_time/http_time-1)*100:.1f}%")
```

**证书相关测试**：
```bash
# 查看证书信息
openssl s_client -connect example.com:443 -servername example.com

# 证书有效期检查
echo | openssl s_client -connect example.com:443 2>/dev/null | \
openssl x509 -noout -dates

# 证书链验证
curl -vvv https://example.com 2>&1 | grep -E "(certificate|SSL|TLS)"
```

**在接口测试中的应用**：

**1. HTTP接口测试**：
```python
import requests

# HTTP接口测试
def test_http_api():
    url = "http://api.example.com/users"
    headers = {"Content-Type": "application/json"}
    data = {"name": "test", "email": "test@example.com"}
    
    response = requests.post(url, json=data, headers=headers)
    
    assert response.status_code == 201
    assert "id" in response.json()
```

**2. HTTPS接口测试**：
```python
import requests
import ssl

# HTTPS接口测试
def test_https_api():
    url = "https://api.example.com/users"
    headers = {"Content-Type": "application/json"}
    data = {"name": "test", "email": "test@example.com"}
    
    # 验证SSL证书
    response = requests.post(url, json=data, headers=headers, verify=True)
    
    # 检查安全响应头
    assert "Strict-Transport-Security" in response.headers
    assert response.url.startswith("https://")
    assert response.status_code == 201
```

**3. 安全测试**：
```python
import requests

def security_test():
    """HTTPS安全特性测试"""
    base_url = "https://api.example.com"
    
    # 测试强制HTTPS重定向
    http_response = requests.get("http://api.example.com", allow_redirects=False)
    assert http_response.status_code == 301
    assert http_response.headers["Location"].startswith("https://")
    
    # 测试HSTS头
    https_response = requests.get(base_url)
    assert "Strict-Transport-Security" in https_response.headers
    
    # 测试证书
    assert https_response.url.startswith("https://")
    
    print("✓ HTTPS安全测试通过")
```

**实际测试场景**：

**1. 混合内容测试**：
```javascript
// 测试HTTPS页面加载HTTP资源的问题
function testMixedContent() {
    // 在HTTPS页面中
    fetch('http://api.example.com/data')  // 会被浏览器阻止
        .then(response => console.log(response))
        .catch(error => console.error('Mixed content blocked:', error));
}
```

**2. SSL/TLS版本兼容性测试**：
```bash
# 测试不同TLS版本支持
nmap --script ssl-enum-ciphers -p 443 example.com

# 测试弱加密算法
testssl.sh https://example.com
```

**3. 证书链测试**：
```python
import ssl
import socket

def test_certificate_chain(hostname, port=443):
    """测试SSL证书链"""
    try:
        context = ssl.create_default_context()
        with socket.create_connection((hostname, port)) as sock:
            with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                cert = ssock.getpeercert()
                print(f"证书主题: {cert['subject']}")
                print(f"证书颁发者: {cert['issuer']}")
                print(f"有效期: {cert['notBefore']} - {cert['notAfter']}")
                return True
    except Exception as e:
        print(f"证书验证失败: {e}")
        return False
```

**最佳实践建议**：
1. **生产环境强制使用HTTPS**
2. **启用HSTS防止协议降级攻击**
3. **使用强加密算法和安全的TLS版本**
4. **定期更新SSL证书**
5. **实施Content Security Policy(CSP)**

### ⭐⭐ HTTP的报文结构和常见状态码
**难度**：⭐⭐
**频率**：🔥🔥🔥

**标准答案**：
HTTP报文结构是理解Web通信的基础，分为请求报文和响应报文：

**HTTP请求报文结构**：
```bash
请求行 (Request Line)
请求头 (Request Headers)
空行
请求体 (Request Body, 可选)
```

**具体示例**：
```http
POST /api/users HTTP/1.1                    ← 请求行
Host: api.example.com                       ← 请求头开始
Content-Type: application/json
Content-Length: 45
Authorization: Bearer eyJhbGciOiJIUzI1NiI...
User-Agent: Mozilla/5.0 (Windows NT 10.0)
Accept: application/json
Connection: keep-alive                      ← 请求头结束
                                           ← 空行
{"name": "张三", "email": "zhang@test.com"}   ← 请求体
```

**HTTP响应报文结构**：
```bash
状态行 (Status Line)
响应头 (Response Headers)
空行
响应体 (Response Body, 可选)
```

**具体示例**：
```http
HTTP/1.1 201 Created                       ← 状态行
Server: nginx/1.18.0                       ← 响应头开始
Content-Type: application/json
Content-Length: 78
Location: /api/users/123
Cache-Control: no-cache
Set-Cookie: session_id=abc123; HttpOnly
Access-Control-Allow-Origin: *             ← 响应头结束
                                          ← 空行
{"id": 123, "name": "张三", "email": "zhang@test.com"}  ← 响应体
```

**HTTP状态码分类**：

**1xx 信息性状态码**：
```bash
100 Continue        - 继续请求，客户端可继续发送请求体
101 Switching Protocols - 协议切换（如WebSocket升级）
```

**2xx 成功状态码**：
```bash
200 OK             - 请求成功
201 Created        - 资源创建成功
202 Accepted       - 请求已接受，但未完成处理
204 No Content     - 成功但无返回内容
206 Partial Content - 部分内容（断点续传）
```

**3xx 重定向状态码**：
```bash
301 Moved Permanently    - 永久重定向
302 Found               - 临时重定向
304 Not Modified        - 资源未修改，使用缓存
307 Temporary Redirect  - 临时重定向（保持方法）
308 Permanent Redirect  - 永久重定向（保持方法）
```

**4xx 客户端错误**：
```bash
400 Bad Request         - 请求语法错误
401 Unauthorized       - 需要身份认证
403 Forbidden          - 服务器拒绝访问
404 Not Found          - 资源不存在
405 Method Not Allowed - HTTP方法不允许
409 Conflict           - 资源冲突
422 Unprocessable Entity - 语法正确但语义错误
429 Too Many Requests  - 请求过于频繁
```

**5xx 服务器错误**：
```bash
500 Internal Server Error - 服务器内部错误
502 Bad Gateway          - 网关错误
503 Service Unavailable  - 服务不可用
504 Gateway Timeout      - 网关超时
```

**常用请求头详解**：
```bash
Host: api.example.com              # 目标主机名（必需）
User-Agent: curl/7.68.0           # 客户端信息
Accept: application/json          # 可接受的响应格式
Content-Type: application/json    # 请求体格式
Content-Length: 123               # 请求体长度
Authorization: Bearer token       # 认证信息
Cache-Control: no-cache           # 缓存控制
Cookie: session_id=abc123         # Cookie信息
```

**常用响应头详解**：
```bash
Server: nginx/1.18.0              # 服务器信息
Content-Type: application/json    # 响应体格式
Content-Length: 456               # 响应体长度
Location: /api/users/123          # 重定向地址
Set-Cookie: session_id=abc123     # 设置Cookie
Cache-Control: max-age=3600       # 缓存策略
ETag: "abc123"                    # 资源版本标识
Last-Modified: Wed, 07 Jan 2025   # 最后修改时间
```

**在测试中的实际应用**：

**1. 请求报文测试**：
```python
import requests

def test_http_request():
    """测试HTTP请求报文"""
    url = "https://httpbin.org/post"
    
    headers = {
        "Content-Type": "application/json",
        "User-Agent": "TestAgent/1.0",
        "Accept": "application/json",
        "Custom-Header": "test-value"
    }
    
    data = {"name": "test", "value": 123}
    
    response = requests.post(url, json=data, headers=headers)
    
    # 验证请求被正确发送
    request_data = response.json()
    assert request_data["headers"]["Content-Type"] == "application/json"
    assert request_data["headers"]["User-Agent"] == "TestAgent/1.0"
    assert request_data["json"]["name"] == "test"
    
    print("✓ HTTP请求报文测试通过")
```

**2. 响应报文测试**：
```python
def test_http_response():
    """测试HTTP响应报文"""
    response = requests.get("https://httpbin.org/json")
    
    # 验证状态行
    assert response.status_code == 200
    assert response.reason == "OK"
    
    # 验证响应头
    assert "application/json" in response.headers["Content-Type"]
    assert int(response.headers["Content-Length"]) > 0
    
    # 验证响应体
    json_data = response.json()
    assert isinstance(json_data, dict)
    
    print("✓ HTTP响应报文测试通过")
```

**3. 状态码测试**：
```python
def test_status_codes():
    """测试各种HTTP状态码"""
    base_url = "https://httpbin.org/status"
    
    test_cases = [
        (200, "成功"),
        (201, "创建成功"),
        (400, "客户端错误"),
        (401, "未授权"),
        (404, "未找到"),
        (500, "服务器错误")
    ]
    
    for status_code, description in test_cases:
        response = requests.get(f"{base_url}/{status_code}")
        assert response.status_code == status_code
        print(f"✓ {status_code} {description} 测试通过")
```

**4. 请求方法测试**：
```python
def test_http_methods():
    """测试不同HTTP方法"""
    base_url = "https://httpbin.org"
    
    # GET请求
    response = requests.get(f"{base_url}/get")
    assert response.status_code == 200
    
    # POST请求
    response = requests.post(f"{base_url}/post", json={"test": "data"})
    assert response.status_code == 200
    
    # PUT请求
    response = requests.put(f"{base_url}/put", json={"test": "data"})
    assert response.status_code == 200
    
    # DELETE请求
    response = requests.delete(f"{base_url}/delete")
    assert response.status_code == 200
    
    print("✓ HTTP方法测试通过")
```

**实用的HTTP调试技巧**：
```bash
# 使用curl查看完整HTTP报文
curl -v -X POST https://httpbin.org/post \
     -H "Content-Type: application/json" \
     -d '{"name": "test"}'

# 使用curl只查看响应头
curl -I https://httpbin.org/get

# 使用curl保存响应头到文件
curl -D headers.txt https://httpbin.org/get
```

---

## 📊 题目总结

### 按难度分级
- **⭐ 基础级**：20题 - 网络基础概念、协议分层
- **⭐⭐ 中级**：25题 - HTTP协议、TCP/UDP特性
- **⭐⭐⭐ 高级**：15题 - 网络调优、安全机制

### 按重要程度
- **🔥🔥🔥 必考**：30题 - 核心概念，面试必问
- **🔥🔥 常考**：20题 - 协议细节，需要掌握
- **🔥 偶考**：10题 - 高级特性，加分项

### 学习路径建议
1. **网络基础**：理解OSI模型、TCP/IP协议栈
2. **HTTP协议**：掌握HTTP/HTTPS原理和应用
3. **网络工具**：熟练使用调试和监控工具
4. **性能优化**：理解网络性能影响因素
5. **安全机制**：掌握网络安全基础知识

### 测试场景应用
- **接口测试**：HTTP协议理解和调试
- **性能测试**：网络延迟和带宽分析
- **安全测试**：HTTPS配置和漏洞检测
- **兼容性测试**：不同协议版本的兼容性

---
**更新日期**：2025-01-07  
**涵盖题目**：60道  
**适用岗位**：高级测试开发工程师